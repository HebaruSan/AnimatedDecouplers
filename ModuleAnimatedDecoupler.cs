// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.Linq; 
using KSP;
using UnityEngine;

namespace AnimatedDecoupler
{
	public class ModuleAnimatedDecoupler : ModuleDecouple
	{
		[KSPField]
		public string animationName;

		protected Animation anim;

		[KSPField(isPersistant = true)]
		public bool animationComplete = false;

		// Sarbian x64 fix
		AttachNode attachNode;
		Part coupledPart;
		List<Part> coupledParts;
		bool didForce = false;
		int pFrameCount;
		//

		public ModuleAnimatedDecoupler ():
		base()
		{
		}

		public override void OnStart (StartState state)
		{
			GameEvents.onStageSeparation.Add (checkForDecoupling);
			base.OnStart (state);
			Debug.Log ("ModuleAnimatedDecoupler.OnStart(), isDecoupled = " + this.isDecoupled.ToString ());
			anim = part.FindModelAnimators(animationName).FirstOrDefault();
			if ((object)this.anim == null)
			{
				Debug.Log ("ModuleAnimatedDecoupler: Animations not found");
			}
			else
			{
				Debug.Log ("ModuleAnimatedDecoupler.OnStart() - Animation found named " + animationName);
				// If Decoupled or animation already played then set animation to end.
				if (this.animationComplete || this.isDecoupled)
				{
					this.anim[animationName].normalizedTime = 1f;
				}
			}
			if (this.explosiveNodeID == "srf")
			{
				this.attachNode = base.part.srfAttachNode;
			}
			else
			{
				this.attachNode = base.part.findAttachNode(this.explosiveNodeID);
			}
			if (this.attachNode == null)
			{
				Print("Error: No attachnode found with id " + this.explosiveNodeID);
			}
			didForce = this.isDecoupled;
		}

		public void checkForDecoupling(EventReport separationData)
		{
			if (separationData.eventType == FlightEvents.STAGESEPARATION && separationData.origin == this.part)
			{
				// PROBABLY got called because we decoupled, but no way to know because ModuleDecouple doesn't SET isDecoupled until after the event fires. 
				if (!this.animationComplete || !this.anim.IsPlaying (animationName))
				{
					this.anim.Play (animationName);
					this.animationComplete = true;
					this.isDecoupled = true;
					Debug.Log ("ModuleAnimatedDecoupler.onStageSeparation() triggered animation " + this.animationName);
				}
			}
		}
		// Disabling; OnActive() not reliable for determining decoupled state and can be triggered by other mods.
		// Using GameEvents.onStageSeparation instead.
		/*
		public override void OnActive()
		{
			Debug.Log ("ModuleAnimatedDecoupler.OnActive() start; isDecoupled = " + this.isDecoupled.ToString () + ", animationComplete = " + this.animationComplete.ToString ());
			base.OnActive ();
			if (this.isDecoupled && (object)anims != null && !animationComplete) 
			{
				try
				{
					this.anim.Play (animationName);
					this.animationComplete = true;
					Debug.Log ("ModuleAnimatedDecoupler played animation " + this.animationName + "!");
				} 
				catch (Exception e)
				{
					Debug.Log ("ModuleAnimatedDecoupler error! " + e.Message);
				}
				Debug.Log ("ModuleAnimatedDecoupler.OnActive() finished; isDecoupled = " + this.isDecoupled.ToString () + ", animationComplete = " + this.animationComplete.ToString ());
			}
			else
			{
				Debug.Log ("ModuleAnimatedDecoupler unable to play animation (OnActive)");
			}
		}
		*/

		// Sarbian x64 fix
		public void FixedUpdate()
		{
			if (!this.isDecoupled)
			{
				coupledPart = base.part.parent;
				if (this.isOmniDecoupler)
				{
					coupledParts = new List<Part>(base.part.children.ToArray());
				}
				else
				{
					if (this.attachNode.attachedPart != null)
					{
						coupledPart = this.attachNode.attachedPart;
					}
				}
				pFrameCount = 1;
			}
			else if (!didForce)
			{
				
				if (pFrameCount != 0)
				{
					//Print("Waiting for 1 more physic frame");
					pFrameCount--;
				}
				else
				{
					Vector3 direction = Vector3.zero;
					Vector3 force = Vector3.zero;
					
					if (this.isOmniDecoupler)
					{
						int num = coupledParts.Count + 1;
						foreach (Part current in coupledParts)
						{
							direction = Vector3.Normalize(base.part.transform.position - current.transform.position);
							force = direction * (-this.ejectionForce / (float)num);
							Print("Force = " + force.magnitude);
							current.Rigidbody.AddForce(force, ForceMode.Force);
						}
						if (coupledPart != null)
						{
							direction = Vector3.Normalize(base.part.transform.position - coupledPart.transform.position);
							force = direction * (-this.ejectionForce / (float)num);
							Print("Force = " + force.magnitude);
							coupledPart.Rigidbody.AddForce(direction * (-this.ejectionForce / (float)num), ForceMode.Force);
						}
					}
					else
					{
						if (coupledPart != null)
						{
							direction = Vector3.Normalize(base.part.transform.position - coupledPart.transform.position);
							force = direction * (this.ejectionForce * 0.5f);
							base.part.Rigidbody.AddForce(force, ForceMode.Force);
							coupledPart.Rigidbody.AddForce(-force, ForceMode.Force);
							Print("Force = " + force.magnitude);
						}
					}
					didForce = true;
				}
			}
		}
		
		private static void Print(String s)
		{
			MonoBehaviour.print("[ModuleDecoupleX64] " + s);
		}
	}
}